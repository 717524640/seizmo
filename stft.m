function [varargout]=stft(data,varargin)
%STFT    Short Time Fourier Transform (aka Sliding Spectra) of SEIZMO data
%
%    Usage:    stft(data)
%              stft(data,...,'width',percent,...)
%              stft(data,...,'units',type,...)
%              stft(data,...,'overlap',percent,...)
%              stft(data,...,'pow2pad',power,...)
%              stft(data,...,'colormap',cmap,...)
%              stft(data,...,'freqrange',frange,...)
%              stft(data,...,'dbrange',dbrange,...)
%              stft(data,...,'fontcolor',fcolor,...)
%              stft(data,...,'axis',handle,...)
%              data=stft(...)
%
%    Description: STFT(DATA) plots records in SEIZMO struct DATA as a trace
%     above a spectrogram (for easy visual comparison).  Multiple records
%     are plotted in a series of subplots.  All records must be evenly
%     sampled time series records.  The spectrogram plot is generated by
%     taking windows of 2.5% the records' length with an overlap from one
%     window to the next of 75% for a total of 157 windows per record.  The
%     spectrogram is actually the power spectral density (PSD) in decibels
%     normalized so that 0dB is the maximum.  The plots are drawn in a new
%     figure window.
%
%     STFT(DATA,...,'WIDTH',PERCENT,...) specifies an alternative window
%     width.  Smaller windows will provide better time resolution at the
%     cost of frequency resolution.  The default width is 2.5%.
%
%     STFT(DATA,...,'UNITS',TYPE,...) changes the window width unit type.
%     The available choices are '%', 'N', & 'S'.  The default is '%'.  The
%     other choices allow for specifying the width in samples ('N') or in
%     seconds ('S').  Changing the type does not change the numeric value
%     of the window width (ie 2.5% becomes 2.5s).
%
%     STFT(DATA,...,'OVERLAP',PERCENT,...) indicates the overlap between
%     adjacent windows.  The default is 75%.  Higher overlap provides a
%     smoother spectrogram along the time axis.  Changing the window width
%     units does not change the overlap units!
%
%     STFT(DATA,...,'POW2PAD',POWER,...) controls the fft zero padding to
%     the next power of 2.  The default value is 1 which pads to the next
%     power of 2 plus 1 more.  Higher powers provide higher frequency
%     resolution but can take considerably more computation.
%
%     STFT(DATA,...,'COLORMAP',CMAP,...) alters the colormap used in the
%     spectrogram plots.  The default colormap is FIRE.  The colormap may
%     be a Nx3 RGB triplet array or a string that may be evaluated to a Nx3
%     RGB triplet.
%
%     STFT(DATA,...,'FREQRANGE',FRANGE,...) specifies the frequency range
%     to plot in the spectrogram.  The default FRANGE is [0 Fnyquist].
%     FRANGE must be [FREQLOW FREQHIGH].
%
%     STFT(DATA,...,'DBRANGE',DBRANGE,...) rescales the colormap to extend
%     to the decibel ranges in DBRANGE.  DBRANGE should be in [DBLO DBHI].
%     The default is [MINDB 0], which has no impact.
%
%     STFT(DATA,...,'FONTCOLOR',FCOLOR,...) chooses the font color for all
%     the plots drawn by STFT.  FCOLOR may be a RGB triplet or a short/long
%     color name (ie 'k', 'yellow', etc).  The default value is 'w', which
%     you will likely want to change if you are specifying an axis to plot
%     in (next option).
%
%     STFT(DATA,...,'AXIS',HANDLE,...) plots the entire set of spectrograms
%     in the space allocated to HANDLE.  Useful for compiling different
%     information into a single figure.
%
%     DATA=STFT(...) returns with the spectrogram PSD stored as the
%     dependent component data in SEIZMO struct DATA.  This means that the
%     records are of XYZ datatype.  B,E,DELTA,NXSIZE,XMINIMUM,XMAXIMUM
%     reflect window times.  NYSIZE, YMINIMUM, YMAXIMUM reflect the
%     frequency info.  NPTS is the number of pixels in the spectrogram.
%
%    Notes:
%     - the plot order proceeds left to right, top to bottom
%
%    Header changes: B, E, DELTA, NPTS, NXSIZE, NYSIZE, IFTYPE,
%                    DEPMEN, DEPMIN, DEPMAX, XMINIMUM, XMAXIMUM,
%                    YMINIMUM, YMAXIMUM
%
%    Examples:
%     Plot records with spectrograms showing 0-0.02Hz limited to -30dB:
%      stft(data,'fr',[0 0.02],'dbr',[-30 0]);
%
%     Plot 4 records in a subplot:
%      h=subplot(3,3,5);
%      stft(data(1:4),'axis',h,'fc','k');
%
%    See also: DFT, CUT, SPECTROGRAM

%     Version History:
%        Apr. 26, 2010 - initial version
%        May   5, 2010 - fully working version
%        May   7, 2010 - fix overlap bug
%        July  8, 2010 - plot name fix & nargchk fix
%
%     Written by Garrett Euler (ggeuler at wustl dot edu)
%     Last Updated July  8, 2010 at 18:25 GMT

% todo:

% check nargin
error(nargchk(1,inf,nargin));
if(mod(nargin-1,2))
    error('seizmo:stft:badNumInputs',...
        'Unpaired Option/Value!');
end

% check data structure
versioninfo(data,'dep');

% turn off struct checking
oldseizmocheckstate=seizmocheck_state(false);

% attempt spectrogram
try
    % check headers
    data=checkheader(data);
    
    % verbosity
    verbose=seizmoverbose;
    
    % number of records
    nrecs=numel(data);
    
    % require evenly spaced time series
    iftype=getenumid(data,'iftype');
    leven=getlgc(data,'leven');
    if(any(strcmpi(leven,'false')))
        error('seizmo:stft:badLEVEN',...
            ['Record(s):\n' sprintf('%d ',find(strcmpi(leven,'false'))) ...
            '\nInvalid operation on unevenly sampled record(s)!']);
    elseif(any(~strcmpi(iftype,'itime') & ~strcmpi(iftype,'ixy')))
        error('seizmo:stft:badIFTYPE',...
            ['Record(s):\n' sprintf('%d ',...
            find(~strcmpi(iftype,'itime') & ~strcmpi(iftype,'ixy'))) ...
            '\nDatatype of record(s) in DATA must be Timeseries or XY!']);
    end
    
    % valid string option values
    valid.units={'%' 'per' 'percent' ...
                 'n' 'samp' 'samples' ...
                 's' 'sec' 'seconds'};
    valid.cname={'b' 'c' 'g' 'k' 'm' 'r' 'w' 'y' ...
        'blue' 'cyan' 'green' 'black' 'magenta' 'red' 'white' 'yellow'};
    
    % option defaults
    varargin=[{'u' '%' 'w' 2.5 'o' 75 'p' 1 'c' 'fire' 'h' 0 ...
        'd' [] 'f' [] 'a' [] 'fc' 'w'} varargin];
    
    % check options
    if(~iscellstr(varargin(1:2:end)))
        error('seizmo:stft:badOption',...
            'All Options must be specified with a string!');
    end
    for i=1:2:numel(varargin)
        % skip empty
        skip=false;
        if(isempty(varargin{i+1})); skip=true; end
        
        % check option is available
        switch lower(varargin{i})
            case {'u' 'unit' 'units'}
                if(skip); continue; end
                if(ischar(varargin{i+1}))
                    varargin{i+1}=cellstr(varargin{i+1});
                end
                if(~iscellstr(varargin{i+1}) ...
                        || any(~ismember(varargin{i+1},valid.units)) ...
                        || ~any(numel(varargin{i+1})==[1 nrecs]))
                    error('seizmo:stft:badInput',...
                        ['UNITS must be one of the following:' ...
                        sprintf('%s ',valid.units{:})]);
                end
                units=varargin{i+1};
                if(isscalar(units)); units(1:nrecs,1)=units; end
            case {'w' 'window' 'width' 'length' 'len'}
                if(skip); continue; end
                if(~isreal(varargin{i+1})  ...
                        || ~any(numel(varargin{i+1})==[1 nrecs]) ...
                        || any(varargin{i+1}<=0))
                    error('seizmo:stft:badInput',...
                        'WIDTH must be a real-valued scalar/vector >0!');
                end
                width=varargin{i+1};
                if(isscalar(width)); width(1:nrecs,1)=width; end
            case {'o' 'over' 'olap' 'overlap'}
                if(skip); continue; end
                if(~isreal(varargin{i+1}) ...
                        || ~any(numel(varargin{i+1})==[1 nrecs]) ...
                        || any(varargin{i+1}<0 | varargin{i+1}>100))
                    error('seizmo:stft:badInput',...
                        'OVERLAP must be between 0-100 (in %%)!');
                end
                overlap=varargin{i+1};
                if(isscalar(overlap)); overlap(1:nrecs,1)=overlap; end
            case {'p' 'p2p' 'padpower' 'pow2pad'}
                if(skip); continue; end
                if(~isreal(varargin{i+1}) ...
                        || ~any(numel(varargin{i+1})==[1 nrecs]) ...
                        || any(varargin{i+1}~=fix(varargin{i+1})))
                    error('seizmo:stft:badInput',...
                        'POW2PAD must be an integer!');
                end
                pow2pad=varargin{i+1};
                if(isscalar(pow2pad)); pow2pad(1:nrecs,1)=pow2pad; end
            case {'c' 'cmap' 'color' 'colormap'}
                if(skip); continue; end
                if(ischar(varargin{i+1}))
                    varargin{i+1}=cellstr(varargin{i+1});
                end
                if(isreal(varargin{i+1}) && ndims(varargin{i+1})==2 ...
                        && size(varargin{i+1},2)==3 ...
                        && all(varargin{i+1}(:)>=0 & varargin{i+1}(:)<=1))
                    cmap=varargin(i+1);
                elseif(iscellstr(varargin{i+1}))
                    cmap=varargin{i+1};
                else
                    error('seizmo:stft:badInput',...
                        ['COLORMAP must be a colormap function\n'...
                        'string or a Nx3 RGB triplet array!']);
                end
                if(isscalar(cmap)); cmap(1:nrecs,1)=cmap; end
            case {'h' 'hr' 'hotrod'}
                % secret option!!!
                if(skip); continue; end
                if(~isreal(varargin{i+1}) ...
                        || ~any(numel(varargin{i+1})==[1 nrecs]) ...
                        || any(varargin{i+1}<0 | varargin{i+1}>1))
                    error('seizmo:stft:badInput',...
                        'HOTROD must be between 0 & 1!');
                end
                hotrod=varargin{i+1};
                if(size(hotrod,1)==1); hotrod(1:nrecs,1)=hotrod; end
            case {'d' 'db' 'dbr' 'dbrange'}
                if(skip); continue; end
                if(~isreal(varargin{i+1}) || size(varargin{i+1},2)~=2 ...
                        || ~any(size(varargin{i+1},1)==[1 nrecs]) ...
                        || any(varargin{i+1}(:,1)>varargin{i+1}(:,2)))
                    error('seizmo:stft:badInput',...
                        'DBRANGE must be Nx2 array of [DBLOW DBHIGH]!');
                end
                dbrange=varargin{i+1};
                if(size(dbrange,1)==1); dbrange=dbrange(ones(nrecs,1),:); end
            case {'f' 'fr' 'freq' 'frange' 'freqrange'}
                if(skip); continue; end
                if(~isreal(varargin{i+1}) || size(varargin{i+1},2)~=2 ...
                        || ~any(size(varargin{i+1},1)==[1 nrecs]) ...
                        || any(varargin{i+1}(:,1)>varargin{i+1}(:,2)) ...
                        || any(varargin{i+1}<0))
                    error('seizmo:stft:badInput',...
                        'FREQRANGE must be Nx2 array of [FREQLO FREQHI]!');
                end
                frange=varargin{i+1};
                if(size(frange,1)==1); frange=frange(ones(nrecs,1),:); end
            case {'a' 'ax' 'axis'}
                if(~isempty(varargin{i+1}) && (~isreal(varargin{i+1}) ...
                        || ~isscalar(varargin{i+1})))
                    error('seizmo:stft:badInput',...
                        'AXIS must be an axis handle!');
                end
                h=varargin{i+1};
            case {'fc' 'font' 'fontcolor'}
                if(skip); continue; end
                if(isreal(varargin{i+1}) ...
                        && isequal(size(varargin{i+1}),[1 3]) ...
                        && all(varargin{i+1}(:)>=0 & varargin{i+1}(:)<=1))
                    fc=varargin{i+1};
                elseif(size(varargin{i+1},1)==1 ...
                        && ismember(varargin{i+1},valid.cname))
                    fc=varargin{i+1};
                else
                    error('seizmo:stft:badInput',...
                        ['COLORMAP must be a color name\n'...
                        'string or a 1x3 RGB triplet!']);
                end
            otherwise
                error('seizmo:stft:badOption',...
                    'Unknown Option: %s',varargin{i});
        end
    end
    
    % identify width units
    pw=ismember(units,{'%' 'per' 'percent'});
    nw=ismember(units,{'n' 'samp' 'samples'});
    sw=ismember(units,{'s' 'sec' 'seconds'});
    
    % convert width/overlap/pow2pad to proper units (samples)
    [b,delta,npts,ncmp]=getheader(data,'b','delta','npts','ncmp');
    if(any(pw)); width(pw)=ceil(width(pw).*npts(pw)/100); end
    if(any(nw)); width(nw)=ceil(width(nw)); end
    if(any(sw)); width(sw)=ceil(width./delta); end
    overlap=min(width-1,ceil(overlap.*width/100));
    pow2pad=2.^(nextpow2n(width)+pow2pad);
    
    % plotting setup
    if(~nargout)
        % make new figure if no axes handle passed
        if(isempty(h) || ~ishandle(h))
            bgc=invertcolor(fc);
            figure('color',bgc);
            h=gca;
        end
        
        % get positioning
        axes(h);
        op=get(h,'outerposition');
        fh=get(h,'parent');
        delete(h);
        
        % number of columns
        ncol=round(sqrt(nrecs));
        nrow=ceil(nrecs/ncol);
        
        % outer position of each subplot
        % [left bottom width height]
        pwidth=op(3)/ncol;
        height=op(4)/nrow;
        left=op(1):pwidth:op(1)+op(3)-pwidth;
        left=left(ones(nrow,1),:)';
        bottom=op(2):height:op(2)+op(4)-height;
        bottom=flipud(bottom(ones(ncol,1),:)')';
        
        % for amplitude labeling
        idep=getenumdesc(data,'idep');
        
        % record coloring
        colors=hsv(nrecs);
        
        % plot constants
        sh=0.6;
        sw=0.8;
        tpl=min([0.0875 (1-sh)*height sh*height sw*pwidth (1-sw)*pwidth]);
        jt=2/3*tpl;
        cbw=0.05;
    end
    
    % detail message
    if(verbose)
        disp('Getting Short Time Fourier Transform of Record(s)');
        print_time_left(0,nrecs);
    end
    
    % loop over records
    e=nan(nrecs,1); nxsize=e; nysize=e; depmen=e; depmin=e; depmax=e;
    for i=1:nrecs
        % skip dataless
        if(~npts(i)); continue; end
        
        % return spectrograms
        if(nargout)
            % get spectrogram
            P=cell(ncmp(i),1);
            for j=1:ncmp(i)
                [P{j},F,T,P{j}]=spectrogram(double(data(i).dep(:,j)),...
                    width(i),overlap(i),pow2pad(i),1/delta(i));
                P{j}=P{j}(:); % make column vector
            end
            
            % assign power spectra to dep
            data(i).dep=cell2mat(P);
            
            % get fields
            % Differences from SAC (!!!):
            % - b/e/delta are timing related
            % - xminimum/xmaximum/yminimum/ymaximum are time/freq values
            b(i)=b(i)+T(1);
            e(i)=b(i)+T(end);
            delta(i)=(e(i)-b(i))/(numel(T)-1);
            npts(i)=numel(P{1});
            nxsize(i)=numel(T);
            nysize(i)=numel(F);
            depmen(i)=mean(data(i).dep(:));
            depmin(i)=min(data(i).dep(:));
            depmax(i)=max(data(i).dep(:));
        else % plotting
            % how this is gonna look
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %        record name        %
            %    +---------------+-+    %
            % amp|  seismogram   |c|    %
            %    +---------------+b|    %
            %  f |               |a|    %
            %  r |  spectrogram  |r|    %
            %  e |               | |    %
            %  q +---------------+-+    %
            %        time (sec)   dB    %
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            
            % plot record
            figure(fh);
            h1=axes('outerposition',[left(i) bottom(i)+sh*height ...
                sw*pwidth (1-sh)*height],...
                'position',[left(i)+tpl bottom(i)+sh*height ...
                sw*pwidth-tpl (1-sh)*height-jt]);
            time=b(i)+(0:npts(i)-1).'*delta(i);
            plot(time,data(i).dep(:,1),'color',colors(i,:),'linewidth',1);
            ylabel(idep{i});
            title(texlabel(data(i).name,'literal'));
            set(gca,'color','none');
            set(gca,'xcolor',fc,'ycolor',fc);
            set(get(gca,'YLabel'),'color',fc);
            set(get(gca,'title'),'color',fc);
            grid on;
            
            % let matlab sig proc box handle the psd estimation
            [S,F,T,P]=spectrogram(double(data(i).dep),...
                width(i),overlap(i),pow2pad(i),1/delta(i));
            P=10*log10(abs(P));
            
            % truncate to frequency range
            if(~exist('frange','var') || isempty(frange))
                frng=[min(F) max(F)];
            else
                frng=frange(i,:);
            end
            fidx=F>=frng(1) & F<=frng(2);
            F=F(fidx);
            P=P(fidx,:);
            
            % normalization
            maxp=max(P(:));
            P=P-maxp;
            
            % special normalization
            minp=min(P(:));
            P(P<minp*(1-hotrod(i)))=minp;
            
            % fix timing
            T=T+b(i);
            
            % deal with dbrange
            if(~exist('dbrange','var') || isempty(dbrange))
                dbrng=[min(P(:)) max(P(:))];
            else
                dbrng=dbrange(i,:);
            end
            
            % plot spectrogram ourselves
            figure(fh,'name','STFT -- SEIZMO');
            h2=axes('outerposition',...
                [left(i) bottom(i) sw*pwidth sh*height],...
                'position',[left(i)+tpl bottom(i)+tpl ...
                sw*pwidth-tpl sh*height-tpl]);
            imagesc(T,F,P,dbrng);
            xlabel('Time (sec)');
            ylabel('Freq (Hz)');
            set(gca,'color','none');
            set(gca,'xcolor',fc,'ycolor',fc);
            set(get(gca,'XLabel'),'color',fc);
            set(get(gca,'YLabel'),'color',fc);
            colormap(cmap{i});
            axis xy tight;
            grid on;
            
            % sync times of timeseries and spectrogram
            set(h1,'xlim',get(h2,'xlim'));
            
            % turn off tick labels on timeseries
            set(h1,'xticklabel',[]);
            
            % plot colorbar
            % entire height
            % 25% of width
            c=colorbar('peer',h2,'position',...
                [left(i)+sw*pwidth bottom(i)+tpl ...
                cbw*pwidth height-tpl-jt]);
            xlabel(c,'dB')
            set(c,'xcolor',fc,'ycolor',fc);
            set(get(c,'XLabel'),'color',fc);
        end
        
        % detail message
        if(verbose); print_time_left(i,nrecs); end
    end
    
    % update headers if there is output args
    if(~nargout); return; end
    varargout{1}=changeheader(data,'b',b,'e',e,'delta',delta,...
        'npts',npts,'iftype','ixyz','nxsize',nxsize,'nysize',nysize,...
        'depmen',depmen,'depmin',depmin,'depmax',depmax,...
        'xminimum',b,'xmaximum',e,'yminimum',0,'ymaximum',1./(2*delta));
    
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    
    % rethrow error
    error(lasterror)
end

end
