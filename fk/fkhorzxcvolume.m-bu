function [varargout]=fkhorzxcvolume(rdata,tdata,smax,spts,frng,polar)
%FKHORZXCVOLUME    Returns frequency-wavenumber space for horz. xc data
%
%    Usage:    [rvol,lvol]=fkhorzxcvolume(rrxc,ttxc,smax,spts,frng)
%              [rvol,lvol]=fkhorzxcvolume(rrxc,ttxc,smax,spts,frng,polar)
%
%    Description: [RVOL,LVOL]=FKHORZXCVOLUME(RRXC,TTXC,SMAX,SPTS,FRNG)
%     calculates the Rayleigh & Love energy moving through an array in
%     frequency-wavenumber space utilizing the horizontal cross correlation
%     datasets RRXC & TTXC.  To allow for easier interpretation between
%     frequencies, the energy is mapped into frequency-slowness space.  The
%     array info and correlograms are contained in the SEIZMO structs RRXC
%     & TTXC.  RRXC is expected to contain the pairwise radial-radial
%     correlations and TTXC is expected to contain the pairwise
%     transverse-transverse correlations.  This differs from FKVOLUME in
%     that DATA is expected to be correlograms resulting from a multi-
%     channel cross correlation with CORRELATE rather than actual records.
%     This has the advantage of allowing time averaging (aka stacking) of
%     the cross spectra to improve resolution of persistent sources of
%     seismic energy like microseismic energy from storms over the oceans.
%     This also differs from FKXCVOLUME in that horizontals are utilized
%     (FKXCVOLUME is really specific to ZZ correlograms) to get both the
%     Rayleigh (RVOL) & Love (LVOL) energy distributions.  Getting RRXC &
%     TTXC requires rotation of EE, EN, NE, & NN correlation pairs to the
%     RR, RT, TR, & TT directions (no standard function for this yet).  The
%     range of the slowness space is given by SMAX (in s/deg) and extends
%     from -SMAX to SMAX for both East/West and North/South directions.
%     SPTS controls the number of slowness points for both directions
%     (SPTSxSPTS grid).  FRNG gives the frequency range as
%     [FREQLOW FREQHIGH] in Hz.  RVOL & LVOL are structs containing
%     relevant info and the frequency-slowness volume itself.  The struct
%     layout is:
%          .response - frequency-slowness array response
%          .nsta     - number of stations utilized in making map
%          .stla     - station latitudes
%          .stlo     - station longitudes
%          .stel     - station elevations (surface)
%          .stdp     - station depths (from surface)
%          .butc     - UTC start time of data
%          .eutc     - UTC end time of data
%          .npts     - number of time points
%          .delta    - number of seconds between each time point
%          .x        - east/west slowness or azimuth values
%          .y        - north/south or radial slowness values
%          .z        - frequency values
%          .polar    - true if slowness is sampled in polar coordinates 
%          .center   - array center or method
%          .normdb   - what 0dB actually corresponds to
%          .volume   - true if frequency-slowness volume (false for FKMAP)
%
%     Calling FKHORZXCVOLUME with no outputs will automatically plot the
%     Rayleigh frequency-slowness volume using FKFREQSLIDE.
%
%     [RVOL,LVOL]=FKHORZXCVOLUME(RRXC,TTXC,SMAX,SPTS,FRNG,POLAR) specifies
%     if the slowness space is sampled regularly in cartesian or polar
%     coordinates.  Polar coords are useful for slicing the volume by
%     azimuth (pie slice) or slowness magnitude (rings).  Cartesian coords
%     (the default) samples the slowness space regularly in the East/West
%     & North/South directions and so exhibits less distortion of the
%     slowness space.
%
%    Notes:
%     - Records in RRXC & TTXC must have equal number of points, equal
%       sample spacing, the same start time (in absolute time), and be
%       evenly spaced "timeseries" records.  Use functions SYNCHRONIZE,
%       SYNCRATES, & INTERPOLATE to get the timing/sampling the same.
%       Afterwards, use CORRELATE to generate the correlograms.
%     - RRXC & TTXC should only contain one "triangle" of the cross
%       correlation matrix (the one with master record indices that are
%       always lower than the slave record indices).  So for a N station
%       dataset, there should be N*(N-1)/2 correlogram records.  This is
%       easily generated by only using one dataset input to CORRELATE.
%     - The CENTER option (from FKVOLUME) is always 'coarray' here and
%       cannot be changed.
%
%    Examples:
%     Show frequency-slowness volume for a dataset at 20-50s periods:
%      [rvol,lvol]=fkhorzxcvolume(rrxc,ttxc,50,201,[1/50 1/20]);
%      rmov=fkfreqslide(rvol,0); % show once with no delay (make movie too)
%      lmov=fkfreqslide(lvol,0); % show once with no delay (make movie too)
%      h1=figure; % open figure so movie consumes figure
%      h2=figure;
%      movie(h1,rmov,3); % show 3 times
%      movie(h2,lmov,3); % show 3 times
%
%    See also: FKFREQSLIDE, FKXCVOLUME, FKVOLUME, FKMAP, FK4D, FKARF
%              SNYQUIST, KXY2SLOWBAZ, SLOWBAZ2KXY, FKTIMESLIDE, FKVOL2MAP

%     Version History:
%        June  9, 2010 - initial version
%
%     Written by Garrett Euler (ggeuler at wustl dot edu)
%     Last Updated June  9, 2010 at 01:25 GMT

% todo:

% check nargin
error(nargchk(5,6,nargin));

% define some constants
d2r=pi/180;
d2km=6371*d2r;

% check struct
versioninfo(rdata,'dep');
versioninfo(tdata,'dep');

% make sure rr/tt are the same size
ncorr=numel(rdata);
ncorr2=numel(tdata);
if(ncorr~=ncorr2)
    error('seizmo:fkhorzxcvolume:unmatchedXCdata',...
        'XC datasets do not match in size!');
end

% check that number of correlograms corresponds to N stations
nrecs=ceil(sqrt(2*ncorr));
if(nrecs*(nrecs-1)/2~=ncorr)
    error('seizmo:fkhorzxcvolume:badInput',...
        'XC datasets do not appear to be correlation datasets!');
end

% defaults for optionals
if(nargin<6 || isempty(polar)); polar=false; end
center='coarray';

% check inputs
sf=size(frng);
if(~isreal(smax) || ~isscalar(smax) || smax<=0)
    error('seizmo:fkhorzxcvolume:badInput',...
        'SMAX must be a positive real scalar in s/deg!');
elseif(~any(numel(spts)==[1 2]) || any(fix(spts)~=spts) || any(spts<=2))
    error('seizmo:fkhorzxcvolume:badInput',...
        'SPTS must be a positive scalar integer >2!');
elseif(~isreal(frng) || numel(sf)~=2 || sf(2)~=2 || any(frng(:)<=0))
    error('seizmo:fkhorzxcvolume:badInput',...
        'FRNG must be a Nx2 array of [FREQLOW FREQHIGH] in Hz!');
elseif(~isscalar(polar) || (~islogical(polar) && ~isnumeric(polar)))
    error('seizmo:fkhorzxcvolume:badInput',...
        'POLAR must be TRUE or FALSE!');
end
nrng=sf(1);

% turn off struct checking
oldseizmocheckstate=seizmocheck_state(false);

% attempt header check
try
    % check headers
    rdata=checkheader(rdata,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'MULTIPLE_DELTA','ERROR',...
        'MULTIPLE_NPTS','ERROR',...
        'NONINTEGER_REFTIME','ERROR',...
        'UNSET_REFTIME','ERROR',...
        'OUTOFRANGE_REFTIME','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    tdata=checkheader(tdata,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'MULTIPLE_DELTA','ERROR',...
        'MULTIPLE_NPTS','ERROR',...
        'NONINTEGER_REFTIME','ERROR',...
        'UNSET_REFTIME','ERROR',...
        'OUTOFRANGE_REFTIME','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    
    % turn off header checking
    oldcheckheaderstate=checkheader_state(false);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    
    % rethrow error
    error(lasterror)
end

% do fk analysis
try
    % verbosity
    verbose=seizmoverbose;
    
    % require radial & transverse components
    [rmcn,rscn]=getheader(rdata,'kt3','kcmpnm');
    [tmcn,tscn]=getheader(tdata,'kt3','kcmpnm');
    rmcn=char(rmcn); rmcn=rmcn(:,3);
    rscn=char(rscn); rscn=rscn(:,3);
    tmcn=char(tmcn); tmcn=tmcn(:,3);
    tscn=char(tscn); tscn=tscn(:,3);
    if(~isequal(lower(unique(rmcn)),'r') ...
            || ~isequal(lower(unique(rscn)),'r'))
        error('seizmo:fkhorzxcvolume:badRadialData',...
            'RDATA does not appear to be RR XC data!');
    elseif(~isequal(lower(unique(tmcn)),'t') ...
            || ~isequal(lower(unique(tscn)),'t'))
        error('seizmo:fkhorzxcvolume:badTransverseData',...
            'TDATA does not appear to be TT XC data!');
    end
    
    % get matrix indices
    % - make sure it corresponds to lower triangle where rows indicate
    %   slave index and cols indicate master index
    [rcol,rrow]=getheader(rdata,'user0','user1');
    if(any(rcol>=rrow))
        error('seizmo:fkhorzxcvolume:badInput',...
            ['RDATA does not appear to be a multi-channel ' ...
            'cross correlation dataset!']);
    end
    [tcol,trow]=getheader(tdata,'user0','user1');
    if(any(tcol>=trow))
        error('seizmo:fkhorzxcvolume:badInput',...
            ['TDATA does not appear to be a multi-channel ' ...
            'cross correlation dataset!']);
    end
    
    % reorder dataset (for easily getting station locations)
    rdata(sub2lti(nrecs,rrow,rcol))=rdata;
    tdata(sub2lti(nrecs,trow,tcol))=tdata;
    
    % get station locations
    st=[getheader(rdata(1),'ev'); getheader(rdata(1:nrecs-1),'st')];
    st2=[getheader(tdata(1),'ev'); getheader(tdata(1:nrecs-1),'st')];
    if(~isequal(st,st2))
        error('seizmo:fkhorzxcvolume:xcDataMismatch',...
            'XC Datasets have different station locations!');
    end
    stla=st(:,1); stlo=st(:,2);
    stel=st(:,3); stdp=st(:,4);
    
    % rereorder again (this should match the cs matrix in fkvolume)
    [row,col]=getheader(rdata,'user0','user1');
    rdata(sub2uti(nrecs,row,col))=rdata;
    tdata(sub2uti(nrecs,row,col))=tdata;
    
    % require all records to have equal npts, delta, b utc, and 1 cmp
    % - we could drop the b UTC requirement but that would require having a
    %   shift term for each record so we remove the window shift from the
    %   results here (would be useful for surface waves recorded by large
    %   aperture arrays -- at this point just window your phase of choice
    %   and then interpolate the windows so everything starts at the same
    %   time)
    % - this would take a little more effort with cross correlation data
    [npts,delta,butc,eutc]=getheader([rdata(:); tdata(:)],...
        'npts','delta','b utc','e utc');
    butc=cell2mat(butc); eutc=cell2mat(eutc);
    if(size(unique(butc,'rows'),1)~=1)
        error('seizmo:fkhorzxcvolume:badData',...
            'All records in datasets must have equal B (UTC)!');
    end
    if(npts(1)~=npts(end) || delta(1)~=delta(end))
        error('seizmo:fkhorzxcvolume:badData',...
            'XC records must have equal NPTS & DELTA fields!');
    end
    
    % check nyquist
    fnyq=1/(2*delta(1));
    if(any(frng>=fnyq))
        error('seizmo:fkhorzxcvolume:badFRNG',...
            ['FRNG frequencies must be under the nyquist frequency (' ...
            num2str(fnyq) ')!']);
    end
    
    % setup output
    [rvol(1:nrng,1).nsta]=deal(nrecs);
    [rvol(1:nrng,1).stla]=deal(stla);
    [rvol(1:nrng,1).stlo]=deal(stlo);
    [rvol(1:nrng,1).stel]=deal(stel);
    [rvol(1:nrng,1).stdp]=deal(stdp);
    [rvol(1:nrng,1).butc]=deal(butc(1,:));
    [rvol(1:nrng,1).eutc]=deal(eutc(1,:));
    [rvol(1:nrng,1).delta]=deal(delta(1));
    [rvol(1:nrng,1).npts]=deal(npts(1));
    [rvol(1:nrng,1).polar]=deal(polar);
    [rvol(1:nrng,1).center]=deal(center);
    [rvol(1:nrng,1).volume]=deal(true);
    
    % get frequencies (note no extra power for correlations)
    nspts=2^nextpow2(npts(1));
    f=(0:nspts/2)/(delta(1)*nspts);  % only +freq
    
    % extract data (silently)
    seizmoverbose(false);
    rdata=splitpad(rdata,0);
    rdata=records2mat(rdata);
    tdata=splitpad(tdata,0);
    tdata=records2mat(tdata);
    seizmoverbose(verbose);
    
    % get fft
    rdata=fft(rdata,nspts,1);
    tdata=fft(tdata,nspts,1);
    
    % get relative positions of center
    % r=(x  ,y  )
    %     ij  ij
    %
    % position of j as seen from i
    % x is km east
    % y is km north
    %
    % r is 2xNR
    %
    % centerless (make coarray)
    % [ r   r   ... r
    %    11  12      1N
    %   r   r   ... r
    %    21  22      2N
    %    .   .  .    .
    %    .   .   .   .
    %    .   .    .  .
    %   r   r   ... r   ]
    %    N1  N2      NN
    [dist,az]=vincentyinv(...
        stla(:,ones(nrecs,1)),stlo(:,ones(nrecs,1)),...
        stla(:,ones(nrecs,1))',stlo(:,ones(nrecs,1))');
    idx=triu(true(nrecs),1);
    dist=dist(idx);
    az=az(idx);
    az=az*d2r;
    r=[dist(:).*sin(az(:)) dist(:).*cos(az(:))]';
    nidx=size(r,2);
    clear dist az
    
    % make slowness projection arrays
    %
    % p=2*pi*i*s*r
    %
    %     ^   ^
    % u = s * r  (unit vectors dotted)
    %
    %     ^   ^
    % v = s x r  (unit vectors crossed)
    %
    % where s is the slowness vector s=(s ,s ) and is NSx2
    %                                    x  y
    %
    % Note s is actually a collection of slowness vectors who
    % correspond to the slownesses that we want to inspect in
    % the fk analysis.  So p is actually the projection of all
    % slownesses onto all of the position vectors (multiplied
    % by 2*pi*i so we don't have to do that for each frequency
    % later)
    %
    % p,u,v are NSxNR
    smax=smax/d2km;
    if(polar)
        if(numel(spts)==2)
            bazpts=spts(2);
            spts=spts(1);
        else
            bazpts=181;
        end
        smag=(0:spts-1)/(spts-1)*smax;
        [rvol(1:nrng,1).y]=deal(smag'*d2km);
        smag=smag(ones(bazpts,1),:)';
        baz=(0:bazpts-1)/(bazpts-1)*360*d2r;
        [rvol(1:nrng,1).x]=deal(baz/d2r);
        baz=baz(ones(spts,1),:);
        p=2*pi*1i*[smag(:).*sin(baz(:)) smag(:).*cos(baz(:))]*r;
        runit=sqrt(r(1,:).^2+r(2,:).^2);
        runit=[r(1,:)./runit; r(2,:)./runit];
        u=abs([sin(baz(:)) cos(baz(:))]*runit);
        v=abs([sin(baz(:)) -cos(baz(:))]*flipud(runit));
        u(isinf(u) | isnan(u))=1;
        v(isinf(v) | isnan(v))=1;
        clear smag baz
    else % cartesian
        spts=spts(1); bazpts=spts;
        sx=-smax:2*smax/(spts-1):smax;
        [rvol(1:nrng,1).x]=deal(sx*d2km);
        [rvol(1:nrng,1).y]=deal(fliplr(sx*d2km)');
        sx=sx(ones(spts,1),:);
        sy=fliplr(sx)';
        p=2*pi*1i*[sx(:) sy(:)]*r;
        sunit=sqrt(sx(:).^2+sy(:).^2);
        sunit=[sx(:)./sunit sy(:)./sunit];
        runit=sqrt(r(1,:).^2+r(2,:).^2);
        runit=[r(1,:)./runit; r(2,:)./runit];
        u=abs(sunit*runit);
        v=abs([sunit(:,1) -sunit(:,2)]*flipud(runit));
        u(isinf(u) | isnan(u))=1;
        v(isinf(v) | isnan(v))=1;
        clear sx sy
    end
    
    % copy rvol to lvol
    lvol=rvol;
    
    % loop over frequency ranges
    for a=1:nrng
        % get frequencies
        fidx=find(f>=frng(a,1) & f<=frng(a,2));
        rvol(a).z=f(fidx);
        lvol(a).z=f(fidx);
        nfreq=numel(fidx);
        
        % preallocate fk space
        rvol(a).response=zeros(spts,bazpts,nfreq,'single');
        lvol(a).response=zeros(spts,bazpts,nfreq,'single');
        
        % warning if no frequencies
        if(~nfreq)
            warning('seizmo:fkhorzxcvolume:noFreqs',...
                'No frequencies within the range %g to %g Hz!',...
                frng(a,1),frng(a,2));
            continue;
        end
        
        % build complex cross spectra array, cs
        % cs is normalized by the auto spectra.
        %
        % cs is NRxNF
        rcs=rdata(fidx,:)'; % complex conjugate indicates bug somewhere...
        rcs=rcs./abs(rcs);
        tcs=tdata(fidx,:)'; % complex conjugate indicates bug somewhere...
        tcs=tcs./abs(tcs);
        
        % detail message
        if(verbose)
            fprintf('Getting fk Volume for %g to %g Hz\n',...
                frng(a,1),frng(a,2));
            print_time_left(0,nfreq);
        end
        
        % loop over frequencies
        for b=1:nfreq
            % get response
            % - following Koper, Seats, and Benz 2010 in BSSA
            %   by only using the real component
            rvol(a).response(:,:,b)=reshape(...
                10*log10(abs(real(...
                (exp(f(fidx(b))*p).*u)*rcs(:,b)...
                +(exp(f(fidx(b))*p).*v)*tcs(:,b)))/nidx),...
                spts,bazpts);
            lvol(a).response(:,:,b)=reshape(...
                10*log10(abs(real(...
                (exp(f(fidx(b))*p).*u)*tcs(:,b)...
                +(exp(f(fidx(b))*p).*v)*rcs(:,b)))/nidx),...
                spts,bazpts);
            
            % detail message
            if(verbose); print_time_left(b,nfreq); end
        end
        
        % normalize so max peak is at 0dB
        rvol(a).normdb=max(rvol(a).response(:));
        rvol(a).response=rvol(a).response-rvol(a).normdb;
        lvol(a).normdb=max(lvol(a).response(:));
        lvol(a).response=lvol(a).response-lvol(a).normdb;
        
        % plot if no output
        if(~nargout); fkfreqslide(rvol(a)); drawnow; end
    end
    
    % return struct
    if(nargout); varargout{1}=rvol; varargout{2}=lvol; end
    
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    checkheader_state(oldcheckheaderstate);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    checkheader_state(oldcheckheaderstate);
    
    % rethrow error
    error(lasterror)
end

end
