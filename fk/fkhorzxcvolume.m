function [varargout]=fkhorzxcvolume(rr,rt,tr,tt,smax,spts,frng,polar)
%FKHORZXCVOLUME    Returns frequency-wavenumber space for horz. xc data
%
%    Usage:    [rvol,lvol]=fkhorzxcvolume(rr,rt,tr,tt,smax,spts,frng)
%              [rvol,lvol]=fkhorzxcvolume(rr,rt,tr,tt,smax,spts,frng,polar)
%
%    Description: [RVOL,LVOL]=FKHORZXCVOLUME(RR,RT,TR,TT,SMAX,SPTS,FRNG)
%     calculates the Rayleigh & Love energy moving through an array in
%     frequency-wavenumber space utilizing the horizontal cross correlation
%     datasets RR, RT, TR & TT.  To allow for easier interpretation between
%     frequencies, the energy is mapped into frequency-slowness space.  The
%     array info and correlograms are contained in the SEIZMO structs RR,
%     RT, TR, & TT.  RR is expected to contain the pairwise radial-radial
%     correlations and TT is expected to contain the pairwise transverse
%     -transverse correlations (RT/TR give the radial-tranverse & the
%     transverse-radial components - energy on these records is indicative
%     of an anisotropic source distribution).  This also differs from
%     FKXCVOLUME in that horizontals are utilized to retreive both the
%     Rayleigh (RVOL) & Love (LVOL) energy distributions.  FKXCVOLUME does
%     not account for the directional sensitivity of horizontals - it is
%     better suited for vertical components that do not vary in directional
%     sensitivity to plane waves with different propagation directions.
%     The range of the slowness space is given by SMAX (in s/deg) and
%     extends from -SMAX to SMAX for both East/West and North/South
%     directions.  SPTS controls the number of slowness points for both
%     directions (SPTSxSPTS grid).  FRNG gives the frequency range as
%     [FREQLOW FREQHIGH] in Hz.  RVOL & LVOL are structs containing
%     relevant info and the frequency-slowness volume itself.  The struct
%     layout is:
%          .response - frequency-slowness array response
%          .nsta     - number of stations utilized in making map
%          .stla     - station latitudes
%          .stlo     - station longitudes
%          .stel     - station elevations (surface)
%          .stdp     - station depths (from surface)
%          .butc     - UTC start time of data
%          .eutc     - UTC end time of data
%          .npts     - number of time points
%          .delta    - number of seconds between each time point
%          .x        - east/west slowness or azimuth values
%          .y        - north/south or radial slowness values
%          .z        - frequency values
%          .polar    - true if slowness is sampled in polar coordinates 
%          .center   - array center or method
%          .normdb   - what 0dB actually corresponds to
%          .volume   - true if frequency-slowness volume (false for FKMAP)
%
%     Calling FKHORZXCVOLUME with no outputs will automatically plot the
%     Rayleigh frequency-slowness volume using FKFREQSLIDE.
%
%     [RVOL,LVOL]=FKHORZXCVOLUME(RR,RT,TR,TT,SMAX,SPTS,FRNG,POLAR) sets
%     if the slowness space is sampled regularly in cartesian or polar
%     coordinates.  Polar coords are useful for slicing the volume by
%     azimuth (pie slice) or slowness magnitude (rings).  Cartesian coords
%     (the default) samples the slowness space regularly in the East/West
%     & North/South directions and so exhibits less distortion of the
%     slowness space.
%
%    Notes:
%     - Records in RR, RT, TR & TT must have equal number of points, equal
%       sample spacing, the same start time (in absolute time), and be
%       evenly spaced "timeseries" records.  Use functions SYNCHRONIZE,
%       SYNCRATES, & INTERPOLATE to get the timing/sampling the same.
%       Afterwards, use CORRELATE to generate the correlograms.
%     - RR, RT, TR & TT should only contain one "triangle" of the cross
%       correlation matrix (the one with master record indices that are
%       always lower than the slave record indices).  So for a N station
%       dataset, there should be N*(N-1)/2 correlogram records.  This is
%       automatically generated by ROTATE_CORRELATIONS.
%     - The CENTER option (from FKVOLUME) is always 'coarray' here and
%       cannot be changed.
%
%    Examples:
%     Show frequency-slowness volume for a dataset at 20-50s periods:
%      [rvol,lvol]=fkhorzxcvolume(rrxc,ttxc,50,201,[1/50 1/20]);
%      rmov=fkfreqslide(rvol,0); % show once with no delay (make movie too)
%      lmov=fkfreqslide(lvol,0); % show once with no delay (make movie too)
%      h1=figure; % open figure so movie consumes figure
%      h2=figure;
%      movie(h1,rmov,3); % show 3 times
%      movie(h2,lmov,3); % show 3 times
%
%    See also: FKFREQSLIDE, FKXCVOLUME, FKVOLUME, FKMAP, FK4D, FKARF
%              SNYQUIST, KXY2SLOWBAZ, SLOWBAZ2KXY, FKTIMESLIDE, FKVOL2MAP

%     Version History:
%        June  9, 2010 - initial version
%
%     Written by Garrett Euler (ggeuler at wustl dot edu)
%     Last Updated June  9, 2010 at 01:25 GMT

% todo:
% - test against earthquakes
%   - rotate to R/T and run through FKMAP
%   - correlate, rotate, and run through here
%   - do results match?
% - things that might be off
%   - u & v are absolute values
%   - if u & v are not absolute values then v may be opposite sign
%   - all the xc components just added
%     - i'm betting this is wrong

% check nargin
error(nargchk(7,8,nargin));

% define some constants
d2r=pi/180;
d2km=6371*d2r;

% check struct
versioninfo(rr,'dep');
versioninfo(rt,'dep');
versioninfo(tr,'dep');
versioninfo(tt,'dep');

% make sure rr/tt are the same size
ncorr=numel(rr);
ncorr1=numel(tt);
ncorr2=numel(tt);
ncorr3=numel(tt);
if(~isequal(ncorr,ncorr1,ncorr2,ncorr3))
    error('seizmo:fkhorzxcvolume:unmatchedXCdata',...
        'XC datasets do not match in size!');
end

% check that number of correlograms corresponds to N stations
nrecs=ceil(sqrt(2*ncorr));
if(nrecs*(nrecs-1)/2~=ncorr)
    error('seizmo:fkhorzxcvolume:badInput',...
        'XC datasets are not multi-channel correlation datasets!');
end

% defaults for optionals
if(nargin<8 || isempty(polar)); polar=false; end
center='coarray';

% check inputs
sf=size(frng);
if(~isreal(smax) || ~isscalar(smax) || smax<=0)
    error('seizmo:fkhorzxcvolume:badInput',...
        'SMAX must be a positive real scalar in s/deg!');
elseif(~any(numel(spts)==[1 2]) || any(fix(spts)~=spts) || any(spts<=2))
    error('seizmo:fkhorzxcvolume:badInput',...
        'SPTS must be a positive scalar integer >2!');
elseif(~isreal(frng) || numel(sf)~=2 || sf(2)~=2 || any(frng(:)<=0))
    error('seizmo:fkhorzxcvolume:badInput',...
        'FRNG must be a Nx2 array of [FREQLOW FREQHIGH] in Hz!');
elseif(~isscalar(polar) || (~islogical(polar) && ~isnumeric(polar)))
    error('seizmo:fkhorzxcvolume:badInput',...
        'POLAR must be TRUE or FALSE!');
end
nrng=sf(1);

% turn off struct checking
oldseizmocheckstate=seizmocheck_state(false);

% attempt header check
try
    % check headers
    rr=checkheader(rr,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'MULTIPLE_DELTA','ERROR',...
        'MULTIPLE_NPTS','ERROR',...
        'NONINTEGER_REFTIME','ERROR',...
        'UNSET_REFTIME','ERROR',...
        'OUTOFRANGE_REFTIME','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    rt=checkheader(rt,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'MULTIPLE_DELTA','ERROR',...
        'MULTIPLE_NPTS','ERROR',...
        'NONINTEGER_REFTIME','ERROR',...
        'UNSET_REFTIME','ERROR',...
        'OUTOFRANGE_REFTIME','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    tr=checkheader(tr,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'MULTIPLE_DELTA','ERROR',...
        'MULTIPLE_NPTS','ERROR',...
        'NONINTEGER_REFTIME','ERROR',...
        'UNSET_REFTIME','ERROR',...
        'OUTOFRANGE_REFTIME','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    tt=checkheader(tt,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'MULTIPLE_DELTA','ERROR',...
        'MULTIPLE_NPTS','ERROR',...
        'NONINTEGER_REFTIME','ERROR',...
        'UNSET_REFTIME','ERROR',...
        'OUTOFRANGE_REFTIME','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    
    % turn off header checking
    oldcheckheaderstate=checkheader_state(false);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    
    % rethrow error
    error(lasterror)
end

% do fk analysis
try
    % verbosity
    verbose=seizmoverbose;
    
    % require radial & transverse components
    [rrmcn,rrscn]=getheader(rr,'kt3','kcmpnm');
    [rtmcn,rtscn]=getheader(rt,'kt3','kcmpnm');
    [trmcn,trscn]=getheader(tr,'kt3','kcmpnm');
    [ttmcn,ttscn]=getheader(tt,'kt3','kcmpnm');
    rrmcn=char(rrmcn); rrmcn=rrmcn(:,3);
    rrscn=char(rrscn); rrscn=rrscn(:,3);
    rtmcn=char(rtmcn); rtmcn=rtmcn(:,3);
    rtscn=char(rtscn); rtscn=rtscn(:,3);
    trmcn=char(trmcn); trmcn=trmcn(:,3);
    trscn=char(trscn); trscn=trscn(:,3);
    ttmcn=char(ttmcn); ttmcn=ttmcn(:,3);
    ttscn=char(ttscn); ttscn=ttscn(:,3);
    if(~isequal(lower(unique(rrmcn)),'r') ...
            || ~isequal(lower(unique(rrscn)),'r'))
        error('seizmo:fkhorzxcvolume:badRR',...
            'RR does not appear to be Radial-Radial XC data!');
    elseif(~isequal(lower(unique(rtmcn)),'r') ...
            || ~isequal(lower(unique(rtscn)),'t'))
        error('seizmo:fkhorzxcvolume:badRT',...
            'RT does not appear to be Radial-Transverse XC data!');
    elseif(~isequal(lower(unique(trmcn)),'t') ...
            || ~isequal(lower(unique(trscn)),'r'))
        error('seizmo:fkhorzxcvolume:badTR',...
            'TR does not appear to be Transverse-Radial XC data!');
    elseif(~isequal(lower(unique(ttmcn)),'t') ...
            || ~isequal(lower(unique(ttscn)),'t'))
        error('seizmo:fkhorzxcvolume:badTT',...
            'TT does not appear to be Transverse-Transverse XC data!');
    end
    
    % get matrix indices
    % - make sure it corresponds to lower triangle where rows indicate
    %   slave index and cols indicate master index
    [rrcol,rrrow]=getheader(rr,'user0','user1');
    if(any(rrcol>=rrrow))
        error('seizmo:fkhorzxcvolume:badInput',...
            ['RR does not appear to be a multi-channel ' ...
            'cross correlation dataset!']);
    end
    [rtcol,rtrow]=getheader(rt,'user0','user1');
    if(any(rtcol>=rtrow))
        error('seizmo:fkhorzxcvolume:badInput',...
            ['RT does not appear to be a multi-channel ' ...
            'cross correlation dataset!']);
    end
    [trcol,trrow]=getheader(tr,'user0','user1');
    if(any(trcol>=trrow))
        error('seizmo:fkhorzxcvolume:badInput',...
            ['TR does not appear to be a multi-channel ' ...
            'cross correlation dataset!']);
    end
    [ttcol,ttrow]=getheader(tt,'user0','user1');
    if(any(ttcol>=ttrow))
        error('seizmo:fkhorzxcvolume:badInput',...
            ['TT does not appear to be a multi-channel ' ...
            'cross correlation dataset!']);
    end
    
    % reorder dataset (for easily getting station locations)
    rr(sub2lti(nrecs,rrrow,rrcol))=rr;
    rt(sub2lti(nrecs,rtrow,rtcol))=rt;
    tr(sub2lti(nrecs,trrow,trcol))=tr;
    tt(sub2lti(nrecs,ttrow,ttcol))=tt;
    
    % get station locations
    st=[getheader(rr(1),'ev'); getheader(rr(1:nrecs-1),'st')];
    st1=[getheader(rt(1),'ev'); getheader(rt(1:nrecs-1),'st')];
    st2=[getheader(tr(1),'ev'); getheader(tr(1:nrecs-1),'st')];
    st3=[getheader(tt(1),'ev'); getheader(tt(1:nrecs-1),'st')];
    if(~isequal(st,st1,st2,st3))
        error('seizmo:fkhorzxcvolume:xcDataMismatch',...
            'XC Datasets have different station locations!');
    end
    stla=st(:,1); stlo=st(:,2);
    stel=st(:,3); stdp=st(:,4);
    
    % rereorder again (this should match the cs matrix in fkvolume)
    [row,col]=getheader(rr,'user0','user1');
    rr(sub2uti(nrecs,row,col))=rr;
    rt(sub2uti(nrecs,row,col))=rt;
    tr(sub2uti(nrecs,row,col))=tr;
    tt(sub2uti(nrecs,row,col))=tt;
    
    % require all records to have equal npts, delta, b utc, and 1 cmp
    % - we could drop the b UTC requirement but that would require having a
    %   shift term for each record so we remove the window shift from the
    %   results here (would be useful for surface waves recorded by large
    %   aperture arrays -- at this point just window your phase of choice
    %   and then interpolate the windows so everything starts at the same
    %   time)
    % - this would take a little more effort with cross correlation data
    [npts,delta,butc,eutc]=getheader([rr(:); rt(:); tr(:); tt(:)],...
        'npts','delta','b utc','e utc');
    butc=cell2mat(butc); eutc=cell2mat(eutc);
    if(size(unique(butc,'rows'),1)~=1)
        error('seizmo:fkhorzxcvolume:badData',...
            'All records in datasets must have equal B (UTC)!');
    end
    if(~isscalar(unique(npts)) || ~isscalar(unique(delta)))
        error('seizmo:fkhorzxcvolume:badData',...
            'XC records must have equal NPTS & DELTA fields!');
    end
    
    % check nyquist
    fnyq=1/(2*delta(1));
    if(any(frng>=fnyq))
        error('seizmo:fkhorzxcvolume:badFRNG',...
            ['FRNG frequencies must be under the nyquist frequency (' ...
            num2str(fnyq) ')!']);
    end
    
    % setup output
    [rvol(1:nrng,1).nsta]=deal(nrecs);
    [rvol(1:nrng,1).stla]=deal(stla);
    [rvol(1:nrng,1).stlo]=deal(stlo);
    [rvol(1:nrng,1).stel]=deal(stel);
    [rvol(1:nrng,1).stdp]=deal(stdp);
    [rvol(1:nrng,1).butc]=deal(butc(1,:));
    [rvol(1:nrng,1).eutc]=deal(eutc(1,:));
    [rvol(1:nrng,1).delta]=deal(delta(1));
    [rvol(1:nrng,1).npts]=deal(npts(1));
    [rvol(1:nrng,1).polar]=deal(polar);
    [rvol(1:nrng,1).center]=deal(center);
    [rvol(1:nrng,1).volume]=deal(true);
    
    % get frequencies (note no extra power for correlations)
    nspts=2^nextpow2(npts(1));
    f=(0:nspts/2)/(delta(1)*nspts);  % only +freq
    
    % extract data (silently)
    seizmoverbose(false);
    rr=splitpad(rr,0);
    rr=records2mat(rr);
    rt=splitpad(rt,0);
    rt=records2mat(rt);
    tr=splitpad(tr,0);
    tr=records2mat(tr);
    tt=splitpad(tt,0);
    tt=records2mat(tt);
    seizmoverbose(verbose);
    
    % get fft
    rr=fft(rr,nspts,1);
    rt=fft(rt,nspts,1);
    tr=fft(tr,nspts,1);
    tt=fft(tt,nspts,1);
    
    % get relative positions of center
    % r=(x  ,y  )
    %     ij  ij
    %
    % position of j as seen from i
    % x is km east
    % y is km north
    %
    % r is 2xNR
    %
    % centerless (make coarray)
    % [ r   r   ... r
    %    11  12      1N
    %   r   r   ... r
    %    21  22      2N
    %    .   .  .    .
    %    .   .   .   .
    %    .   .    .  .
    %   r   r   ... r   ]
    %    N1  N2      NN
    [dist,az]=vincentyinv(...
        stla(:,ones(nrecs,1)),stlo(:,ones(nrecs,1)),...
        stla(:,ones(nrecs,1))',stlo(:,ones(nrecs,1))');
    idx=triu(true(nrecs),1);
    dist=dist(idx);
    az=az(idx);
    az=az*d2r;
    r=[dist(:).*sin(az(:)) dist(:).*cos(az(:))]';
    nidx=size(r,2);
    clear dist az
    
    % make slowness projection arrays
    %
    % p=2*pi*i*s*r
    %
    %     ^   ^
    % u = s * r  (unit vectors dotted)
    %
    %     ^   ^
    % v = s x r  (unit vectors crossed)
    %
    % where s is the slowness vector s=(s ,s ) and is NSx2
    %                                    x  y
    %
    % Note s is actually a collection of slowness vectors who
    % correspond to the slownesses that we want to inspect in
    % the fk analysis.  So p is actually the projection of all
    % slownesses onto all of the position vectors (multiplied
    % by 2*pi*i so we don't have to do that for each frequency
    % later)
    %
    % p,u,v are NSxNR
    smax=smax/d2km;
    if(polar)
        if(numel(spts)==2)
            bazpts=spts(2);
            spts=spts(1);
        else
            bazpts=181;
        end
        smag=(0:spts-1)/(spts-1)*smax;
        [rvol(1:nrng,1).y]=deal(smag'*d2km);
        smag=smag(ones(bazpts,1),:)';
        baz=(0:bazpts-1)/(bazpts-1)*360*d2r;
        [rvol(1:nrng,1).x]=deal(baz/d2r);
        baz=baz(ones(spts,1),:);
        p=2*pi*1i*[smag(:).*sin(baz(:)) smag(:).*cos(baz(:))]*r;
        runit=sqrt(r(1,:).^2+r(2,:).^2);
        runit=[r(1,:)./runit; r(2,:)./runit];
        u=abs([sin(baz(:)) cos(baz(:))]*runit);
        v=abs([sin(baz(:)) -cos(baz(:))]*flipud(runit));
        u(isinf(u) | isnan(u))=1;
        v(isinf(v) | isnan(v))=1;
        clear smag baz
    else % cartesian
        spts=spts(1); bazpts=spts;
        sx=-smax:2*smax/(spts-1):smax;
        [rvol(1:nrng,1).x]=deal(sx*d2km);
        [rvol(1:nrng,1).y]=deal(fliplr(sx*d2km)');
        sx=sx(ones(spts,1),:);
        sy=fliplr(sx)';
        p=2*pi*1i*[sx(:) sy(:)]*r;
        sunit=sqrt(sx(:).^2+sy(:).^2);
        sunit=[sx(:)./sunit sy(:)./sunit];
        runit=sqrt(r(1,:).^2+r(2,:).^2);
        runit=[r(1,:)./runit; r(2,:)./runit];
        %u=(sunit*runit);
        %v=([sunit(:,1) -sunit(:,2)]*flipud(runit));
        u=abs(sunit*runit);
        v=abs([sunit(:,1) -sunit(:,2)]*flipud(runit));
        u(isinf(u) | isnan(u))=1;
        v(isinf(v) | isnan(v))=1;
        clear sx sy
    end
    
    % copy rvol to lvol
    lvol=rvol;
    
    % loop over frequency ranges
    for a=1:nrng
        % get frequencies
        fidx=find(f>=frng(a,1) & f<=frng(a,2));
        rvol(a).z=f(fidx);
        lvol(a).z=f(fidx);
        nfreq=numel(fidx);
        
        % preallocate fk space
        rvol(a).response=zeros(spts,bazpts,nfreq,'single');
        lvol(a).response=zeros(spts,bazpts,nfreq,'single');
        
        % warning if no frequencies
        if(~nfreq)
            warning('seizmo:fkhorzxcvolume:noFreqs',...
                'No frequencies within the range %g to %g Hz!',...
                frng(a,1),frng(a,2));
            continue;
        end
        
        % build complex cross spectra array, cs
        % cs is normalized by the auto spectra.
        %
        % Note: the complex conjugate indicates a bug somewhere...
        %       probably my correlations are reversed but meh...
        %
        % cs is NRxNF
        rrcs=rr(fidx,:)';
        rrcs=rrcs./abs(rrcs);
        rtcs=rt(fidx,:)';
        rtcs=rtcs./abs(rtcs);
        trcs=tr(fidx,:)';
        trcs=trcs./abs(trcs);
        ttcs=tt(fidx,:)';
        ttcs=ttcs./abs(ttcs);
        
        % detail message
        if(verbose)
            fprintf('Getting fk Volume for %g to %g Hz\n',...
                frng(a,1),frng(a,2));
            print_time_left(0,nfreq);
        end
        
        % loop over frequencies
        for b=1:nfreq
            % get response
            % - Following Koper, Seats, and Benz 2010 in BSSA
            %   by only using the real component.  This matches
            %   best with the beam from doing a 'center' style
            %   beam like the Gerstoft group does but gives
            %   slightly better results (at the cost of x(N-1)/2
            %   more operations).  This is required when using
            %   multi-channel correlation datasets.
            rvol(a).response(:,:,b)=reshape(...
                10*log10(abs(real(...
                (exp(f(fidx(b))*p).*u.*u)*rrcs(:,b)...
                +(exp(f(fidx(b))*p).*u.*v)*rtcs(:,b)...
                +(exp(f(fidx(b))*p).*v.*u)*trcs(:,b)...
                +(exp(f(fidx(b))*p).*v.*v)*ttcs(:,b)))/nidx),...
                spts,bazpts);
            lvol(a).response(:,:,b)=reshape(...
                10*log10(abs(real(...
                (exp(f(fidx(b))*p).*u.*u)*ttcs(:,b)...
                +(exp(f(fidx(b))*p).*u.*v)*trcs(:,b)...
                +(exp(f(fidx(b))*p).*v.*u)*rtcs(:,b)...
                +(exp(f(fidx(b))*p).*v.*v)*rrcs(:,b)))/nidx),...
                spts,bazpts);
            
            % detail message
            if(verbose); print_time_left(b,nfreq); end
        end
        
        % normalize so max peak is at 0dB
        rvol(a).normdb=max(rvol(a).response(:));
        rvol(a).response=rvol(a).response-rvol(a).normdb;
        lvol(a).normdb=max(lvol(a).response(:));
        lvol(a).response=lvol(a).response-lvol(a).normdb;
        
        % plot if no output
        if(~nargout); fkfreqslide(rvol(a)); drawnow; end
    end
    
    % return struct
    if(nargout); varargout{1}=rvol; varargout{2}=lvol; end
    
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    checkheader_state(oldcheckheaderstate);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    checkheader_state(oldcheckheaderstate);
    
    % rethrow error
    error(lasterror)
end

end
