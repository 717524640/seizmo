function [varargout]=fkxcvolume(data,smax,spts,frng,polar)
%FKXCVOLUME    Returns energy map in frequency-wavenumber space for xc data
%
%    Usage:    svol=fkxcvolume(xcdata,smax,spts,frng)
%              svol=fkxcvolume(xcdata,smax,spts,frng,polar)
%              svol=fkxcvolume(xcdata,smax,spts,frng,polar,center)
%
%    Description: SVOL=FKXCVOLUME(XCDATA,SMAX,SPTS,FRNG) calculates the
%     energy moving through an array in frequency-wavenumber space.
%     Actually, to allow for easier interpretation between frequencies,
%     the energy is mapped into frequency-slowness space.  The array info
%     and correlograms are contained in the SEIZMO struct XCDATA.  This
%     differs from FKVOLUME in that DATA is expected to be correlograms
%     resulting from a multi-channel cross correlation with CORRELATE
%     rather than actual records.  This has the advantage of allowing time
%     averaging (aka stacking) of the cross spectra to improve resolution
%     of persistent sources of seismic energy like microseismic energy from
%     storms over the oceans.  The range of the slowness space is given by
%     SMAX (in s/deg) and extends from -SMAX to SMAX for both East/West and
%     North/South directions.  SPTS controls the number of slowness points
%     for both directions (SPTSxSPTS grid).  FRNG gives the frequency range
%     as [FREQLOW FREQHIGH] in Hz.  SVOL is a struct containing relevant
%     info and the frequency-slowness volume itself.  The struct layout is:
%          .response - frequency-slowness array response
%          .nsta     - number of stations utilized in making map
%          .stla     - station latitudes
%          .stlo     - station longitudes
%          .stel     - station elevations (surface)
%          .stdp     - station depths (from surface)
%          .butc     - UTC start time of data
%          .eutc     - UTC end time of data
%          .npts     - number of time points
%          .delta    - number of seconds between each time point
%          .x        - east/west slowness or azimuth values
%          .y        - north/south or radial slowness values
%          .z        - frequency values
%          .polar    - true if slowness is sampled in polar coordinates 
%          .center   - array center or method
%          .normdb   - what 0dB actually corresponds to
%          .volume   - true if frequency-slowness volume (false for FKMAP)
%
%     Calling FKXCVOLUME with no outputs will automatically plot the
%     frequency-slowness volume using FKFREQSLIDE.
%
%     SVOL=FKXCVOLUME(DATA,SMAX,SPTS,FRNG,POLAR) specifies if the slowness
%     space is sampled regularly in cartesian or polar coordinates.  Polar
%     coords are useful for slicing the volume by azimuth (pie slice) or
%     slowness magnitude (rings).  Cartesian coords (the default) samples
%     the slowness space regularly in the East/West & North/South
%     directions and so exhibits less distortion of the slowness space.
%
%    Notes:
%     - Records in DATA must have equal number of points, equal sample
%       spacing, the same start time (in absolute time), and be evenly
%       spaced "timeseries" records.  Use functions SYNCHRONIZE, SYNCRATES,
%       & INTERPOLATE to get the timing/sampling the same.  Afterwards, use
%       CORRELATE to generate the correlograms.
%     - DATA should only contain one "triangle" of the cross correlation
%       matrix.  So for a N station dataset, there should be N*(N-1)/2
%       correlogram records.  This is easily generated by only using one
%       dataset input to CORRELATE.
%     - The CENTER option (from FKVOLUME) is always 'coarray' here and
%       cannot be changed.
%
%    Examples:
%     Show frequency-slowness volume for a dataset at 20-50s periods:
%      xcdata=correlate(data);
%      svol=fkxcvolume(xcdata,50,201,[1/50 1/20]);
%      mov=fkfreqslide(svol,0); % show once with no delay (make movie too)
%      h=figure; % open figure so movie consumes figure
%      movie(h,mov,10); % show 10 times
%
%    See also: FKFREQSLIDE, FKVOLUME, FKMAP, FK4D, FKARF, PLOTFKARF
%              SNYQUIST, KXY2SLOWBAZ, SLOWBAZ2KXY, FKTIMESLIDE, FKVOL2MAP

%     Version History:
%        May  13, 2010 - initial version
%
%     Written by Garrett Euler (ggeuler at wustl dot edu)
%     Last Updated May  13, 2010 at 01:10 GMT

% todo:

% check nargin
msg=nargchk(4,5,nargin);
if(~isempty(msg)); error(msg); end

% define some constants
d2r=pi/180;
d2km=6371*d2r;

% check struct
versioninfo(data,'dep');

% defaults for optionals
if(nargin<5 || isempty(polar)); polar=false; end
center='coarray';

% check inputs
sf=size(frng);
if(~isreal(smax) || ~isscalar(smax) || smax<=0)
    error('seizmo:fkxcvolume:badInput',...
        'SMAX must be a positive real scalar in s/deg!');
elseif(~any(numel(spts)==[1 2]) || any(fix(spts)~=spts) || any(spts<=2))
    error('seizmo:fkxcvolume:badInput',...
        'SPTS must be a positive scalar integer >2!');
elseif(~isreal(frng) || numel(sf)~=2 || sf(2)~=2 || any(frng(:)<=0))
    error('seizmo:fkxcvolume:badInput',...
        'FRNG must be a Nx2 array of [FREQLOW FREQHIGH] in Hz!');
elseif(~isscalar(polar) || (~islogical(polar) && ~isnumeric(polar)))
    error('seizmo:fkxcvolume:badInput',...
        'POLAR must be TRUE or FALSE!');
end
nrng=sf(1);

% turn off struct checking
oldseizmocheckstate=seizmocheck_state(false);

% attempt header check
try
    % check headers
    data=checkheader(data,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'MULTIPLE_DELTA','ERROR',...
        'MULTIPLE_NPTS','ERROR',...
        'NONINTEGER_REFTIME','ERROR',...
        'UNSET_REFTIME','ERROR',...
        'OUTOFRANGE_REFTIME','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    
    % turn off header checking
    oldcheckheaderstate=checkheader_state(false);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
end

% do fk analysis
try
    % verbosity
    verbose=seizmoverbose;
    
    % number of correlograms
    ncorr=numel(data);
    
    % check that number of correlograms corresponds to N stations
    nrecs=ceil(sqrt(2*ncorr));
    if(nrecs*(nrecs-1)/2~=ncorr)
        error('seizmo:fkxcvolume:badInput',...
            'DATA does not appear to be a correlation dataset!');
    end
    
    % get matrix indices
    % - make sure it corresponds to lower triangle where rows indicate
    %   slave index and cols indicate master index
    [col,row]=getheader(data,'user0','user1');
    if(any(col>=row))
        error('seizmo:fkxcvolume:badInput',...
            ['DATA does not appear to be a multi-channel ' ...
            'cross correlation dataset!']);
    end
    
    % reorder dataset (for easily getting station locations)
    data(sub2lti(nrecs,row,col))=data;
    
    % get station locations
    st=[getheader(data(1),'ev'); getheader(data(1:nrecs-1),'st')];
    stla=st(:,1); stlo=st(:,2);
    stel=st(:,3); stdp=st(:,4);
    
    % rereorder again (this should match the cs matrix in fkvolume)
    [row,col]=getheader(data,'user0','user1');
    data(sub2uti(nrecs,row,col))=data;
    
    % require all records to have equal npts, delta, b utc, and 1 cmp
    % - we could drop the b UTC requirement but that would require having a
    %   shift term for each record so we remove the window shift from the
    %   results here (would be useful for surface waves recorded by large
    %   aperture arrays -- at this point just window your phase of choice
    %   and then interpolate the windows so everything starts at the same
    %   time)
    % - this would take a little more effort with cross correlation data
    [npts,delta,butc,eutc]=getheader(data,'npts','delta','b utc','e utc');
    butc=cell2mat(butc); eutc=cell2mat(eutc);
    if(size(unique(butc,'rows'),1)~=1)
        error('seizmo:fkxcvolume:badData',...
            'Records in DATA must have equal B (UTC)!');
    end
    
    % check nyquist
    fnyq=1/(2*delta(1));
    if(any(frng>=fnyq))
        error('seizmo:fkxcvolume:badFRNG',...
            ['FRNG frequencies must be under the nyquist frequency (' ...
            num2str(fnyq) ')!']);
    end
    
    % setup output
    [svol(1:nrng,1).nsta]=deal(nrecs);
    [svol(1:nrng,1).stla]=deal(stla);
    [svol(1:nrng,1).stlo]=deal(stlo);
    [svol(1:nrng,1).stel]=deal(stel);
    [svol(1:nrng,1).stdp]=deal(stdp);
    [svol(1:nrng,1).butc]=deal(butc(1,:));
    [svol(1:nrng,1).eutc]=deal(eutc(1,:));
    [svol(1:nrng,1).delta]=deal(delta(1));
    [svol(1:nrng,1).npts]=deal(npts(1));
    [svol(1:nrng,1).polar]=deal(polar);
    [svol(1:nrng,1).center]=deal(center);
    [svol(1:nrng,1).volume]=deal(true);
    
    % get frequencies (note no extra power for correlations)
    nspts=2^nextpow2(npts(1));
    f=(0:nspts/2)/(delta(1)*nspts);  % only +freq
    
    % extract data (silently)
    seizmoverbose(false);
    data=splitpad(data,0);
    data=records2mat(data);
    seizmoverbose(verbose);
    
    % get fft
    data=fft(data,nspts,1);
    
    % get relative positions of center
    % r=(x  ,y  )
    %     ij  ij
    %
    % position of j as seen from i
    % x is km east
    % y is km north
    %
    % r is 2xNR
    %
    % centerless (make coarray)
    % [ r   r   ... r
    %    11  12      1N
    %   r   r   ... r
    %    21  22      2N
    %    .   .  .    .
    %    .   .   .   .
    %    .   .    .  .
    %   r   r   ... r   ]
    %    N1  N2      NN
    [dist,az]=vincentyinv(...
        stla(:,ones(nrecs,1)),stlo(:,ones(nrecs,1)),...
        stla(:,ones(nrecs,1))',stlo(:,ones(nrecs,1))');
    idx=triu(true(nrecs),1);
    dist=dist(idx);
    az=az(idx);
    az=az*d2r;
    r=[dist(:).*sin(az(:)) dist(:).*cos(az(:))]';
    nidx=size(r,2);
    clear dist az
    
    % make projection array
    % p=2*pi*i*s*r
    %
    % where s is the slowness vector s=(s ,s ) and is NSx2
    %                                    x  y
    %
    % Note s is actually a collection of slowness vectors who
    % correspond to the slownesses that we want to inspect in
    % the fk analysis.  So p is actually the projection of all
    % slownesses onto all of the position vectors (multiplied
    % by 2*pi*i so we don't have to do that for each frequency
    % later)
    %
    % p is NSxNR
    smax=smax/d2km;
    if(polar)
        if(numel(spts)==2)
            bazpts=spts(2);
            spts=spts(1);
        else
            bazpts=181;
        end
        smag=(0:spts-1)/(spts-1)*smax;
        [svol(1:nrng,1).y]=deal(smag'*d2km);
        smag=smag(ones(bazpts,1),:)';
        baz=(0:bazpts-1)/(bazpts-1)*360*d2r;
        [svol(1:nrng,1).x]=deal(baz/d2r);
        baz=baz(ones(spts,1),:);
        p=2*pi*1i*[smag(:).*sin(baz(:)) smag(:).*cos(baz(:))]*r;
        clear smag baz
    else % cartesian
        spts=spts(1); bazpts=spts;
        sx=-smax:2*smax/(spts-1):smax;
        [svol(1:nrng,1).x]=deal(sx*d2km);
        [svol(1:nrng,1).y]=deal(fliplr(sx*d2km)');
        sx=sx(ones(spts,1),:);
        sy=fliplr(sx)';
        p=2*pi*1i*[sx(:) sy(:)]*r;
        clear sx sy
    end
    
    % loop over frequency ranges
    for a=1:nrng
        % get frequencies
        fidx=find(f>=frng(a,1) & f<=frng(a,2));
        svol(a).z=f(fidx);
        nfreq=numel(fidx);
        
        % preallocate fk space
        svol(a).response=zeros(spts,bazpts,nfreq);
        
        % warning if no frequencies
        if(~nfreq)
            warning('seizmo:fkxcvolume:noFreqs',...
                'No frequencies within the range %g to %g Hz!',...
                frng(a,1),frng(a,2));
            continue;
        end
        
        % build complex cross spectra array, cs
        % cs is normalized by the auto spectra.
        %
        % cs is NRxNF
        cs=data(fidx,:)'; % complex conjugate indicates a bug somewhere...
        cs=cs./abs(cs);
        
        % detail message
        if(verbose)
            fprintf('Getting fk Volume for %g to %g Hz\n',...
                frng(a,1),frng(a,2));
            print_time_left(0,nfreq);
        end
        
        % loop over frequencies
        for b=1:nfreq
            % get response
            % - following Koper, Seats, and Benz 2010 in BSSA
            %   by only using the real component
            svol(a).response(:,:,b)=reshape(...
                10*log10(abs(real(exp(f(fidx(b))*p)*cs(:,b)))/nidx),...
                spts,bazpts);
            
            % detail message
            if(verbose); print_time_left(b,nfreq); end
        end
        
        % normalize so max peak is at 0dB
        svol(a).normdb=max(svol(a).response(:));
        svol(a).response=svol(a).response-svol(a).normdb;
        
        % plot if no output
        if(~nargout); fkfreqslide(svol(a)); drawnow; end
    end
    
    % return struct
    if(nargout); varargout{1}=svol; end
    
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    checkheader_state(oldcheckheaderstate);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    checkheader_state(oldcheckheaderstate);
    
    % rethrow error
    error(lasterror)
end

end
